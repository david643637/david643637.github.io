<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Prevents browser handling of touch events like scrolling */
        }
        .touch-control-grid {
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
        }
        #up-button { grid-area: up; }
        #left-button { grid-area: left; }
        #right-button { grid-area: right; }
        #down-button { grid-area: down; }

        /* Animation for Game Over screen */
        #gameOverScreen {
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-lg mx-auto text-center mb-4">
        <h1 class="text-4xl md:text-5xl font-bold text-green-400 mb-2">SNAKE</h1>
        <div class="flex justify-center gap-4 text-lg md:text-xl">
            <div class="bg-gray-800 rounded-lg p-2 px-4">
                Score: <span id="score" class="font-bold text-yellow-400">0</span>
            </div>
            <div class="bg-gray-800 rounded-lg p-2 px-4">
                Best: <span id="bestScore" class="font-bold text-yellow-400">0</span>
            </div>
        </div>
    </div>

    <div id="game-container" class="relative w-full max-w-lg mx-auto" style="aspect-ratio: 1/1;">
        <canvas id="gameCanvas" class="bg-gray-800 rounded-lg shadow-2xl border-4 border-green-500 w-full h-full"></canvas>
        <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-lg hidden" style="opacity: 0;">
            <h2 class="text-4xl text-red-500 font-bold mb-4">GAME OVER</h2>
            <p class="text-xl mb-2">Your Score: <span id="finalScore" class="text-yellow-400">0</span></p>
            <button id="restartButton" class="mt-4 px-6 py-3 bg-green-500 hover:bg-green-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>
    
    <!-- Touch Controls for Mobile -->
    <div id="touch-controls" class="mt-6 grid touch-control-grid gap-4 w-64 md:hidden">
        <button id="up-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▲</button>
        <button id="left-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">◄</button>
        <button id="right-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">►</button>
        <button id="down-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▼</button>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const bestScoreEl = document.getElementById('bestScore');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartButton = document.getElementById('restartButton');
        
        // --- Game Configuration ---
        const gridSize = 20;
        const SNAKE_SPEED = 10; // Moves per second (game logic update rate)
        let canvasSize = canvas.offsetWidth;
        let tileSize = canvasSize / gridSize;

        // --- Game State ---
        let snake, apple, bomb, direction, score, bestScore, isGameOver, bombTimer;
        let lastUpdateTime = 0;
        let gameAnimationId;
        let lastTail = { x: 10, y: 10 };
        let lastDirection = { x: 0, y: 0 };


        // Animation state
        let particles = [];
        let screenShake = 0;
        let appleEatEffect = null;

        // --- Touch Controls ---
        const upButton = document.getElementById('up-button');
        const downButton = document.getElementById('down-button');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');

        function setupGame() {
            snake = [{ x: 10, y: 10 }];
            direction = { x: 0, y: 0 };
            score = 0;
            bestScore = localStorage.getItem('snakeBestScore') || 0;
            isGameOver = false;
            bomb = null;
            particles = [];
            appleEatEffect = null;
            screenShake = 0;
            if (bombTimer) clearInterval(bombTimer);
            if (gameAnimationId) cancelAnimationFrame(gameAnimationId);

            lastUpdateTime = 0;
            lastTail = { ...snake[0] };
            lastDirection = { ...direction };

            placeApple();
            scheduleBomb();

            scoreEl.textContent = score;
            bestScoreEl.textContent = bestScore;
            gameOverScreen.classList.add('hidden');
            gameOverScreen.classList.remove('flex');
            gameOverScreen.style.opacity = 0;
        }

        function resizeCanvas() {
            canvasSize = canvas.offsetWidth;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            tileSize = canvasSize / gridSize;
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        function gameLoop(currentTime) {
            if (isGameOver) return;

            gameAnimationId = requestAnimationFrame(gameLoop);
            
            if (lastUpdateTime === 0) {
                lastUpdateTime = currentTime;
            }

            const elapsed = currentTime - lastUpdateTime;
            if (elapsed > (1000 / SNAKE_SPEED)) {
                update();
                lastUpdateTime = currentTime - (elapsed % (1000 / SNAKE_SPEED));
            }
            
            const progress = Math.min(1, (currentTime - lastUpdateTime) / (1000 / SNAKE_SPEED));
            draw(progress);
        }

        // Initial setup
        resizeCanvas();
        setupGame();
        gameLoop(0);


        function update() {
            if (direction.x === 0 && direction.y === 0) return;
            
            lastDirection = { ...direction };
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) return gameOver();
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) return gameOver();
            }
            if (bomb && head.x === bomb.x && head.y === bomb.y) return gameOver(true);

            snake.unshift(head);

            if (head.x === apple.x && head.y === apple.y) {
                score++;
                scoreEl.textContent = score;
                appleEatEffect = {x: apple.x, y: apple.y, radius: 0, alpha: 1};
                placeApple();
            } else {
                lastTail = snake.pop();
            }
        }

        function draw(progress) {
            ctx.save();
            if (screenShake > 0) {
                ctx.translate((Math.random() - 0.5) * screenShake, (Math.random() - 0.5) * screenShake);
            }

            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            snake.forEach((segment, index) => {
                const targetPos = segment;
                let sourcePos;
                
                if (index === 0) {
                     sourcePos = { x: segment.x - lastDirection.x, y: segment.y - lastDirection.y };
                     if(lastDirection.x === 0 && lastDirection.y === 0) sourcePos = targetPos;
                } else if (snake[index]) {
                     const prevSegment = snake[index-1];
                     // This logic seems complex, but it interpolates from the segment ahead of it
                     const nextPosOfPrev = {x: prevSegment.x, y: prevSegment.y};
                     const currentPosOfPrev = {x: prevSegment.x-lastDirection.x, y: prevSegment.y-lastDirection.y}
                     sourcePos = snake[index+1] || lastTail;
                }

                // A simpler, more reliable interpolation:
                let prevX, prevY;
                if (index === 0) {
                    prevX = segment.x - lastDirection.x;
                    prevY = segment.y - lastDirection.y;
                } else {
                    // For body segments, their previous position is the *current* position of the segment that follows them in the array
                    // This works because the array shifts on every update.
                    const prevSegment = snake[index + 1] || lastTail;
                    prevX = prevSegment.x;
                    prevY = prevSegment.y;
                }

                const drawX = (prevX + (segment.x - prevX) * progress) * tileSize;
                const drawY = (prevY + (segment.y - prevY) * progress) * tileSize;


                const gradient = ctx.createLinearGradient(drawX, drawY, drawX + tileSize, drawY + tileSize);
                
                if (index === 0) {
                    gradient.addColorStop(0, '#4ade80'); // green-400
                    gradient.addColorStop(1, '#16a34a'); // green-600
                } else {
                    gradient.addColorStop(0, '#34d399'); // green-500
                    gradient.addColorStop(1, '#059669'); // green-700
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(drawX, drawY, tileSize, tileSize);
                ctx.strokeStyle = '#111827'; // gray-900
                ctx.strokeRect(drawX, drawY, tileSize, tileSize);

                // Draw Eyes on Head
                if (index === 0) {
                    const eyeSize = tileSize / 5;
                    ctx.fillStyle = 'white';
                    if (direction.x === 1) { // Right
                        ctx.beginPath();
                        ctx.arc(drawX + tileSize / 2, drawY + tileSize / 4, eyeSize / 2, 0, 2 * Math.PI);
                        ctx.arc(drawX + tileSize / 2, drawY + (tileSize * 3 / 4), eyeSize / 2, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (direction.x === -1) { // Left
                        ctx.beginPath();
                        ctx.arc(drawX + tileSize / 2, drawY + tileSize / 4, eyeSize / 2, 0, 2 * Math.PI);
                        ctx.arc(drawX + tileSize / 2, drawY + (tileSize * 3 / 4), eyeSize / 2, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (direction.y === 1) { // Down
                        ctx.beginPath();
                        ctx.arc(drawX + tileSize / 4, drawY + tileSize / 2, eyeSize / 2, 0, 2 * Math.PI);
                        ctx.arc(drawX + (tileSize * 3 / 4), drawY + tileSize / 2, eyeSize / 2, 0, 2 * Math.PI);
                        ctx.fill();
                    } else { // Up or initial state
                        ctx.beginPath();
                        ctx.arc(drawX + tileSize / 4, drawY + tileSize / 2, eyeSize / 2, 0, 2 * Math.PI);
                        ctx.arc(drawX + (tileSize * 3 / 4), drawY + tileSize / 2, eyeSize / 2, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            });
            
            if (apple) {
                ctx.fillStyle = '#f87171'; // red-400
                ctx.beginPath();
                ctx.arc(apple.x * tileSize + tileSize / 2, apple.y * tileSize + tileSize / 2, tileSize / 2.2, 0, 2 * Math.PI);
                ctx.fill();
            }

            if (appleEatEffect) {
                ctx.strokeStyle = `rgba(248, 113, 113, ${appleEatEffect.alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(appleEatEffect.x * tileSize + tileSize / 2, appleEatEffect.y * tileSize + tileSize / 2, appleEatEffect.radius, 0, 2 * Math.PI);
                ctx.stroke();
                appleEatEffect.radius += tileSize / 4;
                appleEatEffect.alpha -= 0.1;
                if (appleEatEffect.alpha <= 0) appleEatEffect = null;
            }

            if (bomb) {
                ctx.fillStyle = '#6b7280';
                ctx.beginPath();
                ctx.arc(bomb.x * tileSize + tileSize / 2, bomb.y * tileSize + tileSize / 2, tileSize / 2.2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#facc15';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bomb.x * tileSize + tileSize/2, bomb.y * tileSize + tileSize/2);
                ctx.lineTo(bomb.x * tileSize + tileSize/2, bomb.y * tileSize);
                ctx.stroke();
                ctx.lineWidth = 1;
            }
            ctx.restore();
        }
        
        // --- Animation Functions ---

        function createExplosion(gridX, gridY) {
            screenShake = 15;
            const canvasX = gridX * tileSize + tileSize / 2;
            const canvasY = gridY * tileSize + tileSize / 2;
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x: canvasX, y: canvasY, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                    radius: Math.random() * 3 + 2, alpha: 1, decay: Math.random() * 0.03 + 0.01
                });
            }
        }

        function explosionLoop() {
            if (particles.length === 0 && screenShake <= 0) return;
            updateParticles();
            drawExplosion();
            requestAnimationFrame(explosionLoop);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx;
                p.y += p.dy;
                p.alpha -= p.decay;
                if (p.alpha <= 0) particles.splice(i, 1);
            }
            if (screenShake > 0) screenShake -= 1;
        }

        function drawExplosion() {
            ctx.save();
            if (screenShake > 0) {
                ctx.translate((Math.random() - 0.5) * screenShake, (Math.random() - 0.5) * screenShake);
            }
            
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const fade = Math.max(0, 1 - (15 - screenShake) / 15);
            snake.forEach((segment, index) => {
                ctx.fillStyle = `rgba(${index === 0 ? '74, 222, 128' : '52, 211, 153'}, ${fade})`;
                ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
            });

            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(250, 204, 21, ${p.alpha})`;
                ctx.fill();
            });
            ctx.restore();
        }

        // --- Utility Functions ---

        function placeApple() {
            let newPosition;
            do { newPosition = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
            } while (isOccupied(newPosition));
            apple = newPosition;
        }

        function placeBomb() {
            if (bomb) return; 
            let newPosition;
            do { newPosition = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
            } while (isOccupied(newPosition) || (apple && newPosition.x === apple.x && newPosition.y === apple.y));
            bomb = newPosition;
            setTimeout(() => { bomb = null; scheduleBomb(); }, 4000 + Math.random() * 4000);
        }

        function scheduleBomb() {
             bombTimer = setTimeout(placeBomb, 5000 + Math.random() * 5000);
        }

        function isOccupied(position) {
            return snake.some(segment => segment.x === position.x && segment.y === position.y);
        }

        function gameOver(hitBomb = false) {
            if (isGameOver) return;
            isGameOver = true;
            clearInterval(bombTimer);
            if(gameAnimationId) cancelAnimationFrame(gameAnimationId);

            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('snakeBestScore', bestScore);
                bestScoreEl.textContent = bestScore;
            }

            if(hitBomb) {
                createExplosion(snake[0].x, snake[0].y);
                explosionLoop();
                setTimeout(() => showGameOverUI('BOOM!'), 800);
            } else {
                showGameOverUI('GAME OVER');
            }
        }

        function showGameOverUI(message) {
            finalScoreEl.textContent = score;
            gameOverScreen.querySelector('h2').textContent = message;
            gameOverScreen.classList.remove('hidden');
            gameOverScreen.classList.add('flex');
            setTimeout(() => { gameOverScreen.style.opacity = 1; }, 10);
        }
        
        function changeDirection(newDirection) {
             if (snake.length > 1 && direction.x === -newDirection.x && direction.y === -newDirection.y) return;
             direction = newDirection;
        }

        // Event Listeners
        document.addEventListener('keydown', e => {
            if (isGameOver) return;
            switch (e.key) {
                case 'ArrowUp': case 'w': if (direction.y === 0) changeDirection({ x: 0, y: -1 }); break;
                case 'ArrowDown': case 's': if (direction.y === 0) changeDirection({ x: 0, y: 1 }); break;
                case 'ArrowLeft': case 'a': if (direction.x === 0) changeDirection({ x: -1, y: 0 }); break;
                case 'ArrowRight': case 'd': if (direction.x === 0) changeDirection({ x: 1, y: 0 }); break;
            }
        });
        
        upButton.addEventListener('click', () => { if (!isGameOver && direction.y === 0) changeDirection({ x: 0, y: -1 }); });
        downButton.addEventListener('click', () => { if (!isGameOver && direction.y === 0) changeDirection({ x: 0, y: 1 }); });
        leftButton.addEventListener('click', () => { if (!isGameOver && direction.x === 0) changeDirection({ x: -1, y: 0 }); });
        rightButton.addEventListener('click', () => { if (!isGameOver && direction.x === 0) changeDirection({ x: 1, y: 0 }); });

        restartButton.addEventListener('click', () => {
             setupGame();
             gameLoop(0);
        });
    </script>
</body>
</html>

