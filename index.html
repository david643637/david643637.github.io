<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Snake Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Prevents browser handling of touch events like scrolling */
        }
        .touch-control-grid {
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
        }
        #up-button { grid-area: up; }
        #left-button { grid-area: left; }
        #right-button { grid-area: right; }
        #down-button { grid-area: down; }

        #lobbyScreen, #gameOverScreen {
            transition: opacity 0.5s ease-in-out;
        }
        
        #gameIdDisplay:hover {
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="w-full max-w-lg mx-auto text-center flex flex-col items-center justify-center">
        <h1 class="text-4xl md:text-5xl font-bold text-green-400 mb-8">MULTIPLAYER SNAKE</h1>
        <button id="createGameBtn" class="w-full max-w-xs mb-4 px-6 py-3 bg-green-500 hover:bg-green-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105">
            Create Game
        </button>
        <div class="w-full max-w-xs">
            <input type="text" id="gameIdInput" placeholder="Enter Game ID" class="w-full p-3 bg-gray-800 border-2 border-gray-700 rounded-lg text-center uppercase tracking-widest focus:outline-none focus:border-green-500">
            <button id="joinGameBtn" class="w-full mt-2 px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105">
                Join Game
            </button>
        </div>
        <p id="lobbyError" class="text-red-500 mt-4 h-6"></p>
    </div>

    <!-- Game Screen (Initially Hidden) -->
    <div id="gameScreen" class="hidden w-full">
        <div class="w-full max-w-lg mx-auto text-center mb-4">
            <h1 class="text-3xl md:text-4xl font-bold text-green-400 mb-2">SNAKE</h1>
            <div id="gameIdDisplayContainer" class="mb-2">
                Game ID: 
                <span id="gameIdDisplay" title="Click to copy" class="font-bold text-yellow-400 underline decoration-dotted"></span>
            </div>
            <div id="scoresContainer" class="flex justify-center flex-wrap gap-4 text-lg md:text-xl">
                <!-- Scores will be dynamically inserted here -->
            </div>
        </div>

        <div id="game-container" class="relative w-full max-w-lg mx-auto" style="aspect-ratio: 1/1;">
            <canvas id="gameCanvas" class="bg-gray-800 rounded-lg shadow-2xl border-4 border-green-500 w-full h-full"></canvas>
            <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-lg hidden" style="opacity: 0;">
                <h2 class="text-4xl text-red-500 font-bold mb-4">GAME OVER</h2>
                <p class="text-xl mb-2">Waiting for other players...</p>
                <button id="leaveGameBtn" class="mt-4 px-6 py-3 bg-blue-500 hover:bg-blue-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105">
                    Back to Lobby
                </button>
            </div>
        </div>
        
        <div id="touch-controls" class="mt-6 grid touch-control-grid gap-4 w-64 md:hidden mx-auto">
            <button id="up-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▲</button>
            <button id="left-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">◄</button>
            <button id="right-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">►</button>
            <button id="down-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▼</button>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Firebase Config (Provided by environment) ---
        const firebaseConfig = { /* Your Firebase Config Here */ };
        // NOTE: In a real environment, __firebase_config would be populated.
        // For local testing, you must replace the above with your actual config.
        const app = initializeApp(JSON.parse(window.__firebase_config || JSON.stringify(firebaseConfig)));
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- UI Elements ---
        const lobbyScreen = document.getElementById('lobbyScreen');
        const gameScreen = document.getElementById('gameScreen');
        const createGameBtn = document.getElementById('createGameBtn');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const gameIdInput = document.getElementById('gameIdInput');
        const lobbyError = document.getElementById('lobbyError');
        const gameIdDisplay = document.getElementById('gameIdDisplay');
        const scoresContainer = document.getElementById('scoresContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const leaveGameBtn = document.getElementById('leaveGameBtn');

        // --- Game Configuration ---
        const gridSize = 20;
        const SNAKE_SPEED = 10; // Moves per second (game logic update rate)
        const PLAYER_COLORS = ['#4ade80', '#60a5fa', '#f87171', '#fbbf24']; // Green, Blue, Red, Amber
        
        // --- Game State ---
        let localGameState = {};
        let userId;
        let gameId;
        let isHost = false;
        let gameUpdateInterval;
        let unsubscribeFromGame;
        
        let lastUpdateTime = 0;
        let gameAnimationId;

        async function main() {
            try {
                let userCredential;
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    userCredential = await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    userCredential = await signInAnonymously(auth);
                }
                userId = userCredential.user.uid;
                setupLobbyListeners();
            } catch (error) {
                console.error("Authentication failed:", error);
                lobbyError.textContent = "Could not connect to server.";
            }
        }

        function setupLobbyListeners() {
            createGameBtn.onclick = createGame;
            joinGameBtn.onclick = joinGame;
            leaveGameBtn.onclick = leaveGame;
            gameIdDisplay.onclick = () => {
                navigator.clipboard.writeText(gameIdDisplay.textContent)
                    .then(() => {
                        const originalText = gameIdDisplay.textContent;
                        gameIdDisplay.textContent = 'Copied!';
                        setTimeout(() => gameIdDisplay.textContent = originalText, 1500);
                    });
            };
        }

        async function createGame() {
            isHost = true;
            gameId = Math.random().toString(36).substring(2, 7).toUpperCase();
            const playerColor = PLAYER_COLORS[0];

            localGameState = {
                players: {
                    [userId]: {
                        snake: [{ x: 10, y: 10 }],
                        direction: { x: 0, y: 0 },
                        color: playerColor,
                        score: 0,
                        isGameOver: false
                    }
                },
                apple: { x: 15, y: 15 },
                bomb: null,
                hostId: userId,
                status: "playing"
            };

            try {
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                await setDoc(gameRef, localGameState);
                await listenToGame(gameId);
                switchToGameView();
            } catch(error) {
                console.error("Error creating game:", error);
                lobbyError.textContent = "Failed to create game.";
            }
        }
        
        async function joinGame() {
            const idToJoin = gameIdInput.value.toUpperCase();
            if (!idToJoin) {
                lobbyError.textContent = "Please enter a Game ID.";
                return;
            }

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', idToJoin);
            try {
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) {
                    lobbyError.textContent = "Game not found.";
                    return;
                }
                
                const gameData = gameSnap.data();
                const playerCount = Object.keys(gameData.players).length;

                if (playerCount >= PLAYER_COLORS.length) {
                    lobbyError.textContent = "Game is full.";
                    return;
                }

                const playerColor = PLAYER_COLORS[playerCount];
                const newPlayer = {
                    snake: [{ x: 5, y: 5 }],
                    direction: { x: 0, y: 0 },
                    color: playerColor,
                    score: 0,
                    isGameOver: false
                };

                await updateDoc(gameRef, {
                    [`players.${userId}`]: newPlayer
                });

                await listenToGame(idToJoin);
                switchToGameView();

            } catch(error) {
                 console.error("Error joining game:", error);
                 lobbyError.textContent = "Failed to join game.";
            }
        }

        async function leaveGame() {
            if (unsubscribeFromGame) unsubscribeFromGame();
            if (gameUpdateInterval) clearInterval(gameUpdateInterval);
            
            if (!isHost && gameId && userId) {
                 const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                 await updateDoc(gameRef, { [`players.${userId}`]: deleteField() });
            } 

            gameId = null;
            isHost = false;
            unsubscribeFromGame = null;
            localGameState = {};
            
            switchToLobbyView();
        }

        function listenToGame(id) {
            gameId = id;
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            unsubscribeFromGame = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    localGameState = docSnap.data();
                    updateScoresUI();
                    
                    if(!localGameState.players || !localGameState.players[userId]) {
                        // Player was removed from game, possibly by host leaving
                        console.log("Player not found in game state, leaving.");
                        alert("The game has ended or you have been removed.");
                        leaveGame();
                        return;
                    }

                    const myPlayer = localGameState.players[userId];
                    if (myPlayer.isGameOver && !gameOverScreen.classList.contains('flex')) {
                        gameOverScreen.classList.remove('hidden');
                        gameOverScreen.classList.add('flex');
                        setTimeout(() => { gameOverScreen.style.opacity = 1; }, 10);
                    } else if (!myPlayer.isGameOver) {
                        gameOverScreen.classList.add('hidden');
                        gameOverScreen.classList.remove('flex');
                        gameOverScreen.style.opacity = 0;
                    }

                } else {
                    alert("The game has ended.");
                    leaveGame();
                }
            });
        }

        function switchToGameView() {
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameIdDisplay.textContent = gameId;

            resizeCanvas();
            if (isHost) {
                gameUpdateInterval = setInterval(hostGameUpdate, 1000 / SNAKE_SPEED);
            }
            requestAnimationFrame(gameLoop);
        }

        function switchToLobbyView() {
            gameScreen.classList.add('hidden');
            lobbyScreen.classList.remove('hidden');
            gameIdInput.value = '';
            lobbyError.textContent = '';
        }

        function hostGameUpdate() {
            if (!isHost || !localGameState.players) return;

            let nextState = JSON.parse(JSON.stringify(localGameState));
            let appleEaten = false;

            Object.keys(nextState.players).forEach(pId => {
                const player = nextState.players[pId];
                if (player.isGameOver || (player.direction.x === 0 && player.direction.y === 0)) {
                    return;
                }

                const head = { x: player.snake[0].x + player.direction.x, y: player.snake[0].y + player.direction.y };
                
                if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
                    player.isGameOver = true;
                    return;
                }
                for (let i = 1; i < player.snake.length; i++) {
                    if (head.x === player.snake[i].x && head.y === player.snake[i].y) {
                        player.isGameOver = true;
                        return;
                    }
                }
                 if (nextState.bomb && head.x === nextState.bomb.x && head.y === nextState.bomb.y) {
                    player.isGameOver = true;
                    return;
                }

                player.snake.unshift(head);

                if (head.x === nextState.apple.x && head.y === nextState.apple.y) {
                    player.score++;
                    appleEaten = true;
                } else {
                    player.snake.pop();
                }
            });

            if (appleEaten) {
                nextState.apple = getNewRandomPos(nextState);
            }
            
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            setDoc(gameRef, nextState).catch(err => console.error("Host update failed", err));
        }

        function getNewRandomPos(state) {
            let newPosition;
            let occupied = new Set();
            Object.values(state.players).forEach(p => {
                p.snake.forEach(seg => occupied.add(`${seg.x},${seg.y}`));
            });
             if (state.apple) occupied.add(`${state.apple.x},${state.apple.y}`);
             if (state.bomb) occupied.add(`${state.bomb.x},${state.bomb.y}`);

            do {
                newPosition = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
            } while (occupied.has(`${newPosition.x},${newPosition.y}`));
            return newPosition;
        }


        function gameLoop(currentTime) {
            gameAnimationId = requestAnimationFrame(gameLoop);
            draw();
        }

        function draw() {
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!localGameState.players) return;
            
            Object.values(localGameState.players).forEach(player => {
                if (player.isGameOver) return; 
                player.snake.forEach((segment, index) => {
                    ctx.fillStyle = player.color;
                    ctx.fillRect(segment.x * (canvas.width / gridSize), segment.y * (canvas.height / gridSize), (canvas.width / gridSize), (canvas.height / gridSize));
                    if (index === 0) {
                         const eyeSize = (canvas.width / gridSize) / 5;
                         ctx.fillStyle = 'white';
                         ctx.fillRect(segment.x * (canvas.width / gridSize) + eyeSize, segment.y * (canvas.height / gridSize) + eyeSize, eyeSize, eyeSize);
                         ctx.fillRect(segment.x * (canvas.width / gridSize) + (3*eyeSize), segment.y * (canvas.height / gridSize) + eyeSize, eyeSize, eyeSize);
                    }
                });
            });

            if (localGameState.apple) {
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(localGameState.apple.x * (canvas.width / gridSize), localGameState.apple.y * (canvas.height / gridSize), (canvas.width / gridSize), (canvas.height / gridSize));
            }
            if (localGameState.bomb) {
                ctx.fillStyle = '#6b7280';
                 ctx.fillRect(localGameState.bomb.x * (canvas.width / gridSize), localGameState.bomb.y * (canvas.height / gridSize), (canvas.width / gridSize), (canvas.height / gridSize));
            }
        }
        
        function updateScoresUI() {
            if (!localGameState.players) return;
            scoresContainer.innerHTML = '';
            Object.values(localGameState.players).forEach(player => {
                const scoreDiv = document.createElement('div');
                scoreDiv.style.color = player.color;
                scoreDiv.className = `p-2 px-4 rounded-lg font-bold ${player.isGameOver ? 'bg-red-900 line-through' : 'bg-gray-800'}`;
                scoreDiv.innerHTML = `P: <span class="text-yellow-400">${player.score}</span>`;
                scoresContainer.appendChild(scoreDiv);
            });
        }
        
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
        }

        window.addEventListener('resize', resizeCanvas);

        document.addEventListener('keydown', e => {
            if (!gameId || !localGameState.players || !localGameState.players[userId] || localGameState.players[userId].isGameOver) return;
            
            const currentDirection = localGameState.players[userId].direction;
            let newDirection = { ...currentDirection };

            switch (e.key) {
                case 'ArrowUp': case 'w': if (currentDirection.y === 0) newDirection = { x: 0, y: -1 }; break;
                case 'ArrowDown': case 's': if (currentDirection.y === 0) newDirection = { x: 0, y: 1 }; break;
                case 'ArrowLeft': case 'a': if (currentDirection.x === 0) newDirection = { x: -1, y: 0 }; break;
                case 'ArrowRight': case 'd': if (currentDirection.x === 0) newDirection = { x: 1, y: 0 }; break;
            }

            if (newDirection.x !== currentDirection.x || newDirection.y !== currentDirection.y) {
                 const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                 updateDoc(gameRef, { [`players.${userId}.direction`]: newDirection });
            }
        });

        main();

    </script>
</body>
</html>

