<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Snake Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Prevents browser handling of touch events like scrolling */
        }
        .touch-control-grid {
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
        }
        #up-button { grid-area: up; }
        #left-button { grid-area: left; }
        #right-button { grid-area: right; }
        #down-button { grid-area: down; }

        #lobbyScreen, #gameOverScreen {
            transition: opacity 0.5s ease-in-out;
        }
        
        #gameIdDisplay:hover {
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="w-full max-w-lg mx-auto text-center flex flex-col items-center justify-center">
        <h1 class="text-4xl md:text-5xl font-bold text-green-400 mb-8">MULTIPLAYER SNAKE</h1>
        <button id="createGameBtn" class="w-full max-w-xs mb-4 px-6 py-3 bg-green-500 hover:bg-green-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
            Create Game
        </button>
        <div class="w-full max-w-xs">
            <input type="text" id="gameIdInput" placeholder="Enter Game ID" class="w-full p-3 bg-gray-800 border-2 border-gray-700 rounded-lg text-center uppercase tracking-widest focus:outline-none focus:border-green-500">
            <button id="joinGameBtn" class="w-full mt-2 px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Join Game
            </button>
        </div>
        <p id="lobbyStatus" class="text-yellow-400 mt-4 h-6"></p>
    </div>

    <!-- Game Screen (Initially Hidden) -->
    <div id="gameScreen" class="hidden w-full">
        <div class="w-full max-w-lg mx-auto text-center mb-4">
            <h1 class="text-3xl md:text-4xl font-bold text-green-400 mb-2">SNAKE</h1>
            <div id="gameIdDisplayContainer" class="mb-2">
                Game ID: 
                <span id="gameIdDisplay" title="Click to copy" class="font-bold text-yellow-400 underline decoration-dotted"></span>
            </div>
            <div id="scoresContainer" class="flex justify-center flex-wrap gap-4 text-lg md:text-xl">
                <!-- Scores will be dynamically inserted here -->
            </div>
        </div>

        <div id="game-container" class="relative w-full max-w-lg mx-auto" style="aspect-ratio: 1/1;">
            <canvas id="gameCanvas" class="bg-gray-800 rounded-lg shadow-2xl border-4 border-green-500 w-full h-full"></canvas>
            <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-lg hidden" style="opacity: 0;">
                <h2 class="text-4xl text-red-500 font-bold mb-4">GAME OVER</h2>
                <p class="text-xl mb-2">Waiting for other players...</p>
                <button id="leaveGameBtn" class="mt-4 px-6 py-3 bg-blue-500 hover:bg-blue-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105">
                    Back to Lobby
                </button>
            </div>
        </div>
        
        <div id="touch-controls" class="mt-6 grid touch-control-grid gap-4 w-64 md:hidden mx-auto">
            <button id="up-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▲</button>
            <button id="left-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">◄</button>
            <button id="right-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">►</button>
            <button id="down-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▼</button>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- UI Elements ---
        const lobbyScreen = document.getElementById('lobbyScreen');
        const gameScreen = document.getElementById('gameScreen');
        const createGameBtn = document.getElementById('createGameBtn');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const gameIdInput = document.getElementById('gameIdInput');
        const lobbyStatus = document.getElementById('lobbyStatus');
        const gameIdDisplay = document.getElementById('gameIdDisplay');
        const scoresContainer = document.getElementById('scoresContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const leaveGameBtn = document.getElementById('leaveGameBtn');
        const upButton = document.getElementById('up-button');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const downButton = document.getElementById('down-button');

        // --- Game Configuration ---
        const gridSize = 20;
        const SNAKE_SPEED = 10; // Moves per second (game logic update rate)
        const PLAYER_COLORS = ['#4ade80', '#60a5fa', '#f87171', '#fbbf24']; // Green, Blue, Red, Amber
        
        // --- Game State ---
        let localGameState = {};
        let userId;
        let gameId;
        let isHost = false;
        let gameUpdateInterval;
        let unsubscribeFromGame;
        let gameAnimationId;
        
        // --- Firebase State ---
        let app, auth, db;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        function initializeFirebase() {
            try {
                // Use a placeholder for local development if the environment variable is not set.
                const firebaseConfigString = window.__firebase_config || '{"apiKey": "INVALID_KEY"}';
                const firebaseConfig = JSON.parse(firebaseConfigString);

                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "INVALID_KEY") {
                    throw new Error("Firebase configuration is missing or invalid.");
                }

                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                return true;
            } catch (error) {
                console.error("CRITICAL: Firebase initialization failed.", error);
                lobbyStatus.textContent = "Error: Game cannot load.";
                lobbyStatus.className = 'text-red-500 mt-4 h-6';
                createGameBtn.disabled = true;
                joinGameBtn.disabled = true;
                return false;
            }
        }

        async function main() {
            lobbyStatus.textContent = "Connecting to server...";
            try {
                let userCredential;
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    userCredential = await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    userCredential = await signInAnonymously(auth);
                }
                userId = userCredential.user.uid;
                setupLobbyListeners();

                createGameBtn.disabled = false;
                joinGameBtn.disabled = false;
                lobbyStatus.textContent = "Connected. Ready to play!";
                setTimeout(() => { if(lobbyStatus.textContent === "Connected. Ready to play!") lobbyStatus.textContent = "" }, 3000);

            } catch (error) {
                console.error("Authentication failed:", error);
                lobbyStatus.textContent = "Connection failed. Please refresh.";
                lobbyStatus.className = 'text-red-500 mt-4 h-6';
            }
        }

        function setupLobbyListeners() {
            createGameBtn.onclick = createGame;
            joinGameBtn.onclick = joinGame;
            leaveGameBtn.onclick = leaveGame;
            gameIdDisplay.onclick = () => {
                navigator.clipboard.writeText(gameIdDisplay.textContent)
                    .then(() => {
                        const originalText = gameIdDisplay.textContent;
                        gameIdDisplay.textContent = 'Copied!';
                        setTimeout(() => gameIdDisplay.textContent = originalText, 1500);
                    });
            };

            // Touch Controls
            upButton.onclick = () => sendDirectionUpdate({ x: 0, y: -1 });
            downButton.onclick = () => sendDirectionUpdate({ x: 0, y: 1 });
            leftButton.onclick = () => sendDirectionUpdate({ x: -1, y: 0 });
            rightButton.onclick = () => sendDirectionUpdate({ x: 1, y: 0 });
        }

        function sendDirectionUpdate(newDirection) {
            if (!gameId || !localGameState.players || !localGameState.players[userId] || localGameState.players[userId].isGameOver) return;
            
            const currentDirection = localGameState.players[userId].direction;

            if (currentDirection.y !== 0 && newDirection.y !== 0) return;
            if (currentDirection.x !== 0 && newDirection.x !== 0) return;

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            updateDoc(gameRef, { [`players.${userId}.direction`]: newDirection });
        }

        async function createGame() {
            isHost = true;
            gameId = Math.random().toString(36).substring(2, 7).toUpperCase();
            const playerColor = PLAYER_COLORS[0];

            localGameState = {
                players: {
                    [userId]: {
                        snake: [{ x: 10, y: 10 }],
                        direction: { x: 0, y: 0 },
                        color: playerColor,
                        score: 0,
                        isGameOver: false
                    }
                },
                apple: { x: 15, y: 15 },
                bomb: null,
                hostId: userId,
                status: "playing"
            };

            try {
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                await setDoc(gameRef, localGameState);
                listenToGame(gameId);
                switchToGameView();
            } catch(error) {
                console.error("Error creating game:", error);
                lobbyStatus.textContent = "Failed to create game.";
            }
        }
        
        async function joinGame() {
            const idToJoin = gameIdInput.value.toUpperCase();
            if (!idToJoin) {
                lobbyStatus.textContent = "Please enter a Game ID.";
                return;
            }

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', idToJoin);
            try {
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) {
                    lobbyStatus.textContent = "Game not found.";
                    return;
                }
                
                const gameData = gameSnap.data();
                const usedColors = Object.values(gameData.players).map(p => p.color);
                const availableColor = PLAYER_COLORS.find(c => !usedColors.includes(c));

                if (!availableColor) {
                    lobbyStatus.textContent = "Game is full.";
                    return;
                }
                
                const newPlayer = {
                    snake: [getNewRandomPos(gameData)],
                    direction: { x: 0, y: 0 },
                    color: availableColor,
                    score: 0,
                    isGameOver: false
                };

                await updateDoc(gameRef, { [`players.${userId}`]: newPlayer });

                listenToGame(idToJoin);
                switchToGameView();

            } catch(error) {
                 console.error("Error joining game:", error);
                 lobbyStatus.textContent = "Failed to join game.";
            }
        }

        async function leaveGame() {
            if (isHost && gameId) {
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                await deleteDoc(gameRef).catch(err => console.error("Failed to delete game doc", err));
            } 
            else if (!isHost && gameId && userId) {
                 const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                 await updateDoc(gameRef, { [`players.${userId}`]: deleteField() }).catch(err => console.error("Failed to leave game", err));
            }
        }

        function listenToGame(id) {
            gameId = id;
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            unsubscribeFromGame = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    localGameState = docSnap.data();
                    updateScoresUI();
                    
                    if(gameId && (!localGameState.players || !localGameState.players[userId])) {
                        cleanUpAndGoToLobby("You have left the game.");
                        return;
                    }

                    const myPlayer = localGameState.players[userId];
                    if (myPlayer.isGameOver && !gameOverScreen.classList.contains('flex')) {
                        gameOverScreen.classList.remove('hidden');
                        gameOverScreen.classList.add('flex');
                        setTimeout(() => { gameOverScreen.style.opacity = 1; }, 10);
                    } else if (!myPlayer.isGameOver) {
                        gameOverScreen.classList.add('hidden');
                        gameOverScreen.classList.remove('flex');
                        gameOverScreen.style.opacity = 0;
                    }

                } else {
                    cleanUpAndGoToLobby("The host has ended the game.");
                }
            });
        }
        
        function cleanUpAndGoToLobby(message) {
            if (unsubscribeFromGame) unsubscribeFromGame();
            if (gameUpdateInterval) clearInterval(gameUpdateInterval);
            if(gameAnimationId) cancelAnimationFrame(gameAnimationId);

            gameId = null;
            isHost = false;
            unsubscribeFromGame = null;
            localGameState = {};
            
            switchToLobbyView(message);
        }

        function switchToGameView() {
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameIdDisplay.textContent = gameId;

            resizeCanvas();
            if (isHost) {
                gameUpdateInterval = setInterval(hostGameUpdate, 1000 / SNAKE_SPEED);
            }
            gameAnimationId = requestAnimationFrame(gameLoop);
        }

        function switchToLobbyView(message = '') {
            gameScreen.classList.add('hidden');
            lobbyScreen.classList.remove('hidden');
            gameIdInput.value = '';
            lobbyStatus.textContent = message;
        }

        function hostGameUpdate() {
            if (!isHost || !localGameState.players) return;

            let nextState = JSON.parse(JSON.stringify(localGameState));
            let appleEaten = false;

            const allSegments = new Set();
            Object.values(nextState.players).forEach(p => {
                if (p.isGameOver) return;
                p.snake.forEach(seg => allSegments.add(`${seg.x},${seg.y}`));
            });

            Object.keys(nextState.players).forEach(pId => {
                const player = nextState.players[pId];
                if (player.isGameOver || (player.direction.x === 0 && player.direction.y === 0)) {
                    return;
                }

                const head = { x: player.snake[0].x + player.direction.x, y: player.snake[0].y + player.direction.y };
                
                if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
                    player.isGameOver = true; return;
                }
                
                const ownTail = player.snake[player.snake.length - 1];
                const ownTailKey = `${ownTail.x},${ownTail.y}`;
                allSegments.delete(ownTailKey);

                if (allSegments.has(`${head.x},${head.y}`)) {
                    player.isGameOver = true; allSegments.add(ownTailKey); return;
                }
                allSegments.add(ownTailKey);

                 if (nextState.bomb && head.x === nextState.bomb.x && head.y === nextState.bomb.y) {
                    player.isGameOver = true; return;
                }

                player.snake.unshift(head);

                if (head.x === nextState.apple.x && head.y === nextState.apple.y) {
                    player.score++;
                    appleEaten = true;
                } else {
                    player.snake.pop();
                }
            });

            if (appleEaten) {
                nextState.apple = getNewRandomPos(nextState);
            }

            // Bomb logic
            if (!nextState.bomb && Math.random() < 0.02) { // 2% chance per tick to spawn a bomb
                nextState.bomb = getNewRandomPos(nextState);
            } else if (nextState.bomb && Math.random() < 0.05) { // 5% chance per tick to remove bomb
                nextState.bomb = null;
            }
            
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            setDoc(gameRef, nextState).catch(err => console.error("Host update failed", err));
        }

        function getNewRandomPos(state) {
            let newPosition;
            let occupied = new Set();
            Object.values(state.players).forEach(p => {
                p.snake.forEach(seg => occupied.add(`${seg.x},${seg.y}`));
            });
             if (state.apple) occupied.add(`${state.apple.x},${state.apple.y}`);
             if (state.bomb) occupied.add(`${state.bomb.x},${state.bomb.y}`);

            do {
                newPosition = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
            } while (occupied.has(`${newPosition.x},${newPosition.y}`));
            return newPosition;
        }


        function gameLoop() {
            draw();
            gameAnimationId = requestAnimationFrame(gameLoop);
        }

        function draw() {
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!localGameState.players) return;
            
            Object.values(localGameState.players).forEach(player => {
                if (player.isGameOver) return; 
                player.snake.forEach((segment, index) => {
                    ctx.fillStyle = player.color;
                    ctx.fillRect(segment.x * (canvas.width / gridSize), segment.y * (canvas.height / gridSize), (canvas.width / gridSize) -1 , (canvas.height / gridSize) -1);
                    if (index === 0) {
                         const eyeSize = (canvas.width / gridSize) / 5;
                         ctx.fillStyle = 'white';
                         ctx.fillRect(segment.x * (canvas.width / gridSize) + eyeSize, segment.y * (canvas.height / gridSize) + eyeSize, eyeSize, eyeSize);
                         ctx.fillRect(segment.x * (canvas.width / gridSize) + (3*eyeSize), segment.y * (canvas.height / gridSize) + eyeSize, eyeSize, eyeSize);
                    }
                });
            });

            if (localGameState.apple) {
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(localGameState.apple.x * (canvas.width / gridSize), localGameState.apple.y * (canvas.height / gridSize), (canvas.width / gridSize), (canvas.height / gridSize));
            }
            if (localGameState.bomb) {
                ctx.fillStyle = '#6b7280';
                 ctx.fillRect(localGameState.bomb.x * (canvas.width / gridSize), localGameState.bomb.y * (canvas.height / gridSize), (canvas.width / gridSize), (canvas.height / gridSize));
            }
        }
        
        function updateScoresUI() {
            if (!localGameState.players) return;
            scoresContainer.innerHTML = '';
            Object.keys(localGameState.players).sort().forEach((playerId, index) => {
                const player = localGameState.players[playerId];
                const scoreDiv = document.createElement('div');
                scoreDiv.style.color = player.color;
                scoreDiv.className = `p-2 px-4 rounded-lg font-bold ${player.isGameOver ? 'bg-red-900 line-through' : 'bg-gray-800'}`;
                scoreDiv.innerHTML = `P${index + 1}: <span class="text-yellow-400">${player.score}</span>`;
                scoresContainer.appendChild(scoreDiv);
            });
        }
        
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            let size = Math.min(container.offsetWidth, window.innerHeight * 0.6);
            canvas.width = size;
            canvas.height = size;
        }

        window.addEventListener('resize', resizeCanvas);

        document.addEventListener('keydown', e => {
            if (!gameId || !localGameState.players || !localGameState.players[userId] || localGameState.players[userId].isGameOver) return;

            switch (e.key) {
                case 'ArrowUp': case 'w': 
                    sendDirectionUpdate({ x: 0, y: -1 });
                    break;
                case 'ArrowDown': case 's': 
                    sendDirectionUpdate({ x: 0, y: 1 });
                    break;
                case 'ArrowLeft': case 'a': 
                    sendDirectionUpdate({ x: -1, y: 0 });
                    break;
                case 'ArrowRight': case 'd': 
                    sendDirectionUpdate({ x: 1, y: 0 });
                    break;
            }
        });
        
        // --- Start the application ---
        if (initializeFirebase()) {
            main();
        }

    </script>
</body>
</html>

