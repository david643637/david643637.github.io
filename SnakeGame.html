<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Prevents browser handling of touch events like scrolling */
        }
        .touch-control-grid {
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
        }
        #up-button { grid-area: up; }
        #left-button { grid-area: left; }
        #right-button { grid-area: right; }
        #down-button { grid-area: down; }

        /* Animation for Game Over screen */
        #gameOverScreen {
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-lg mx-auto text-center mb-4">
        <h1 class="text-4xl md:text-5xl font-bold text-green-400 mb-2">SNAKE</h1>
        <div class="text-lg md:text-xl bg-gray-800 rounded-lg p-2 inline-block">
            Score: <span id="score" class="font-bold text-yellow-400">0</span>
        </div>
    </div>

    <div id="game-container" class="relative w-full max-w-lg mx-auto" style="aspect-ratio: 1/1;">
        <canvas id="gameCanvas" class="bg-gray-800 rounded-lg shadow-2xl border-4 border-green-500 w-full h-full"></canvas>
        <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-lg hidden" style="opacity: 0;">
            <h2 class="text-4xl text-red-500 font-bold mb-4">GAME OVER</h2>
            <p class="text-xl mb-2">Your Score: <span id="finalScore" class="text-yellow-400">0</span></p>
            <button id="restartButton" class="mt-4 px-6 py-3 bg-green-500 hover:bg-green-600 text-gray-900 font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>
    
    <!-- Touch Controls for Mobile -->
    <div id="touch-controls" class="mt-6 grid touch-control-grid gap-4 w-64 md:hidden">
        <button id="up-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▲</button>
        <button id="left-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">◄</button>
        <button id="right-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">►</button>
        <button id="down-button" class="bg-green-500 p-4 rounded-lg shadow-lg text-2xl active:bg-green-600 transform active:scale-95">▼</button>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartButton = document.getElementById('restartButton');
        
        // --- Game Configuration ---
        const gridSize = 20; // 20x20 grid
        let canvasSize = canvas.offsetWidth;
        let tileSize = canvasSize / gridSize;

        // --- Game State ---
        let snake, apple, bomb, direction, score, isGameOver, gameSpeed, bombTimer, gameLoopTimeoutId;
        // Animation state
        let particles = [];
        let screenShake = 0;
        let appleEatEffect = null;

        // --- Touch Controls ---
        const upButton = document.getElementById('up-button');
        const downButton = document.getElementById('down-button');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');

        function setupGame() {
            // Initialize game state
            snake = [{ x: 10, y: 10 }]; // Start in the middle
            direction = { x: 0, y: 0 };
            score = 0;
            isGameOver = false;
            gameSpeed = 150; // Milliseconds per move
            bomb = null;
            particles = [];
            appleEatEffect = null;
            screenShake = 0;
            if (bombTimer) clearInterval(bombTimer);
            if (gameLoopTimeoutId) clearTimeout(gameLoopTimeoutId);

            // Place the first apple
            placeApple();
            
            // Set up bomb timer
            scheduleBomb();

            // Reset UI
            scoreEl.textContent = score;
            gameOverScreen.classList.add('hidden');
            gameOverScreen.classList.remove('flex');
            gameOverScreen.style.opacity = 0;
        }

        function resizeCanvas() {
            canvasSize = canvas.offsetWidth;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            tileSize = canvasSize / gridSize;
            // Redraw everything on resize
            if(!isGameOver) {
                draw();
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Initial setup
        setupGame();
        resizeCanvas();
        gameLoop();


        function gameLoop() {
            if (isGameOver) {
                return;
            }
            update();
            draw();
            gameLoopTimeoutId = setTimeout(gameLoop, gameSpeed);
        }

        function update() {
            if (isGameOver) return;
            
            // Only start moving if a direction has been chosen
            if (direction.x === 0 && direction.y === 0) {
                return;
            }

            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            // Wall collision
            if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
                return gameOver();
            }

            // Self collision
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return gameOver();
                }
            }
            
            // Bomb collision
            if (bomb && head.x === bomb.x && head.y === bomb.y) {
                return gameOver(true); // Special game over for bomb
            }

            snake.unshift(head);

            // Apple collision
            if (head.x === apple.x && head.y === apple.y) {
                score++;
                scoreEl.textContent = score;
                appleEatEffect = {x: apple.x, y: apple.y, radius: 0, alpha: 1};
                if (gameSpeed > 60) {
                   gameSpeed -= 2;
                }
                placeApple();
            } else {
                snake.pop();
            }
        }

        function draw() {
            ctx.save();
            // Screen Shake effect
            if (screenShake > 0) {
                const dx = (Math.random() - 0.5) * screenShake;
                const dy = (Math.random() - 0.5) * screenShake;
                ctx.translate(dx, dy);
            }

            // Clear canvas
            ctx.fillStyle = '#1f2937'; // bg-gray-800
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw snake
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#4ade80' : '#34d399'; // Lighter green for head
                ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
                ctx.strokeStyle = '#1f2937';
                ctx.strokeRect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
            });

            // Draw apple
            if (apple) {
                ctx.fillStyle = '#f87171'; // red-400
                ctx.beginPath();
                ctx.arc(apple.x * tileSize + tileSize / 2, apple.y * tileSize + tileSize / 2, tileSize / 2.2, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw apple eat effect
            if (appleEatEffect) {
                ctx.strokeStyle = `rgba(248, 113, 113, ${appleEatEffect.alpha})`; // red-400 with alpha
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(appleEatEffect.x * tileSize + tileSize / 2, appleEatEffect.y * tileSize + tileSize / 2, appleEatEffect.radius, 0, 2 * Math.PI);
                ctx.stroke();
                appleEatEffect.radius += tileSize / 4;
                appleEatEffect.alpha -= 0.1;
                if (appleEatEffect.alpha <= 0) {
                    appleEatEffect = null;
                }
            }

            // Draw bomb
            if (bomb) {
                ctx.fillStyle = '#6b7280'; // gray-500
                ctx.beginPath();
                ctx.arc(bomb.x * tileSize + tileSize / 2, bomb.y * tileSize + tileSize / 2, tileSize / 2.2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#facc15'; // yellow-400
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bomb.x * tileSize + tileSize/2, bomb.y * tileSize + tileSize/2);
                ctx.lineTo(bomb.x * tileSize + tileSize/2, bomb.y * tileSize);
                ctx.stroke();
                ctx.lineWidth = 1;
            }
            ctx.restore();
        }
        
        // --- Animation Functions ---

        function createExplosion(gridX, gridY) {
            screenShake = 15;
            const canvasX = gridX * tileSize + tileSize / 2;
            const canvasY = gridY * tileSize + tileSize / 2;
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x: canvasX,
                    y: canvasY,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    radius: Math.random() * 3 + 2,
                    alpha: 1,
                    decay: Math.random() * 0.03 + 0.01
                });
            }
        }

        function explosionLoop() {
            if (particles.length === 0 && screenShake <= 0) return;
            
            updateParticles();
            drawExplosion();
            
            requestAnimationFrame(explosionLoop);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx;
                p.y += p.dy;
                p.alpha -= p.decay;

                if (p.alpha <= 0) particles.splice(i, 1);
            }
            if (screenShake > 0) screenShake -= 1;
        }

        function drawExplosion() {
            ctx.save();
            if (screenShake > 0) {
                const dx = (Math.random() - 0.5) * screenShake;
                const dy = (Math.random() - 0.5) * screenShake;
                ctx.translate(dx, dy);
            }
            
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const fade = Math.max(0, 1 - (15 - screenShake) / 15);
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? `rgba(74, 222, 128, ${fade})` : `rgba(52, 211, 153, ${fade})`;
                ctx.fillRect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
            });

            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(250, 204, 21, ${p.alpha})`; // yellow-400
                ctx.fill();
            });
            ctx.restore();
        }

        // --- Utility Functions ---

        function placeApple() {
            let newPosition;
            do {
                newPosition = {
                    x: Math.floor(Math.random() * gridSize),
                    y: Math.floor(Math.random() * gridSize)
                };
            } while (isOccupied(newPosition));
            apple = newPosition;
        }

        function placeBomb() {
            if (bomb) return; 
            let newPosition;
            do {
                newPosition = {
                    x: Math.floor(Math.random() * gridSize),
                    y: Math.floor(Math.random() * gridSize)
                };
            } while (isOccupied(newPosition) || (apple && newPosition.x === apple.x && newPosition.y === apple.y));
            bomb = newPosition;
            
            setTimeout(() => {
                bomb = null;
                scheduleBomb();
            }, 4000 + Math.random() * 4000); // 4-8 seconds
        }

        function scheduleBomb() {
             const delay = 5000 + Math.random() * 5000; // 5-10 seconds
             bombTimer = setTimeout(placeBomb, delay);
        }

        function isOccupied(position) {
            return snake.some(segment => segment.x === position.x && segment.y === position.y);
        }

        function gameOver(hitBomb = false) {
            if (isGameOver) return;
            isGameOver = true;
            clearTimeout(gameLoopTimeoutId);
            clearInterval(bombTimer);

            if(hitBomb) {
                createExplosion(snake[0].x, snake[0].y);
                explosionLoop();
                setTimeout(() => showGameOverUI('BOOM!'), 800);
            } else {
                showGameOverUI('GAME OVER');
            }
        }

        function showGameOverUI(message) {
            finalScoreEl.textContent = score;
            gameOverScreen.querySelector('h2').textContent = message;
            gameOverScreen.classList.remove('hidden');
            gameOverScreen.classList.add('flex');
            setTimeout(() => {
                gameOverScreen.style.opacity = 1;
            }, 10);
        }
        
        function changeDirection(newDirection) {
             if (direction.x === -newDirection.x && direction.y === -newDirection.y) {
                return;
            }
            direction = newDirection;
        }

        // Event Listeners
        document.addEventListener('keydown', e => {
            if (isGameOver) return;
            switch (e.key) {
                case 'ArrowUp': case 'w':
                    if (direction.y === 0) changeDirection({ x: 0, y: -1 }); break;
                case 'ArrowDown': case 's':
                    if (direction.y === 0) changeDirection({ x: 0, y: 1 }); break;
                case 'ArrowLeft': case 'a':
                    if (direction.x === 0) changeDirection({ x: -1, y: 0 }); break;
                case 'ArrowRight': case 'd':
                    if (direction.x === 0) changeDirection({ x: 1, y: 0 }); break;
            }
        });
        
        upButton.addEventListener('click', () => { if (!isGameOver && direction.y === 0) changeDirection({ x: 0, y: -1 }); });
        downButton.addEventListener('click', () => { if (!isGameOver && direction.y === 0) changeDirection({ x: 0, y: 1 }); });
        leftButton.addEventListener('click', () => { if (!isGameOver && direction.x === 0) changeDirection({ x: -1, y: 0 }); });
        rightButton.addEventListener('click', () => { if (!isGameOver && direction.x === 0) changeDirection({ x: 1, y: 0 }); });

        restartButton.addEventListener('click', () => {
             setupGame();
             gameLoop();
        });
    </script>
</body>
</html>

